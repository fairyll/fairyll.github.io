<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1"><title>常见的设计模式</title><link rel="shortcut icon" href="/images/avatar.png"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/css/highlight.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"></head><body><nav class="main-nav"><a href="/">首页</a><a href="/archives">归档</a></nav><div class="profile"><section id="wrapper"><header id="header"><a href="/about"><img class="2x" id="avatar" src="/images/avatar.png"></a><h1>Fairy</h1><h2></h2></header></section></div><section class="post" id="wrapper"><article><header><h1>常见的设计模式</h1><h2 class="headline">Jun 20, 2018 10:19·955 words
·3 minutes read<span class="tags"></span></h2></header><div id="toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-单例模式"><span class="toc-text">1.单例模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-工厂模式"><span class="toc-text">2.工厂模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-代理模式"><span class="toc-text">3.代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-组成"><span class="toc-text">1.组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-优点"><span class="toc-text">2.优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-模式结构"><span class="toc-text">3.模式结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#静态代理"><span class="toc-text">静态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态代理"><span class="toc-text">动态代理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-装饰者模式"><span class="toc-text">4.装饰者模式</span></a></li></ol></div><section id="post-body"><h2 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h2><p>实现方式:</p>
<blockquote>
</blockquote>
<p>1.在本类内部创建一个私有的静态的本类实例为成员对象</p>
<blockquote>
</blockquote>
<p>2.提供公共的静态访问方法</p>
<p>应用场景:</p>
<blockquote>
<p>（1）资源共享的情况下，避免由于资源操作时导致的性能的损耗等。如数据库连接池的设计,日志文件，应用配置。</p>
</blockquote>
<p>（2）控制资源的情况下，方便资源之间的互相通信。如线程池等。</p>
<h2 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2.工厂模式"></a>2.工厂模式</h2><p>就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。</p>
<p>实现方式:</p>
<blockquote>
</blockquote>
<p>1、工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑。在java中它往往由一个具体类实现。</p>
<blockquote>
</blockquote>
<p>2、抽象产品角色：它一般是具体产品继承的父类或者实现的接口。在java中由接口或者抽象类来实现。</p>
<blockquote>
</blockquote>
<p>3、具体产品角色：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。</p>
<p>应用场景:</p>
<blockquote>
</blockquote>
<p>1)当客户程序不需要知道对象的创建过程。</p>
<blockquote>
</blockquote>
<p>2)客户程序使用的对象存在变动的可能，或者根本就不知道使用哪一个具体的对象。</p>
<h2 id="3-代理模式"><a href="#3-代理模式" class="headerlink" title="3.代理模式"></a>3.代理模式</h2><p>代理模式的关键点是:代理对象与目标对象,代理对象是对目标对象的扩展,并会调用目标对象 </p>
<h3 id="1-组成"><a href="#1-组成" class="headerlink" title="1.组成"></a>1.组成</h3><pre><code>抽象角色:通过接口或抽象类声明真实角色实现的业务方法。

代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。

真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。
</code></pre><h3 id="2-优点"><a href="#2-优点" class="headerlink" title="2.优点"></a>2.优点</h3><pre><code>(1).职责清晰:真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件完成事务，附带的结果就是编程简洁清晰。

(2).代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了中介的作用和保护了目标对象的作用。

(3).高扩展性
</code></pre><h3 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3.模式结构"></a>3.模式结构</h3><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><pre><code>是由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。
</code></pre><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><pre><code>是在实现阶段不用关心代理类，而在运行阶段才指定哪一个对象.
</code></pre><p>应用场景:</p>
<blockquote>
</blockquote>
<p>（1）当我们想要隐藏某个类时，可以为其提供代理类</p>
<blockquote>
</blockquote>
<p>（2）当一个类需要对不同的调用者提供不同的调用权限时，可以使用代理类来实现（代理类不一定只有一个，我们可以建立多个代理类来实现，也可以在一个代理类中进行权限判断来进行不同权限的功能调用）</p>
<blockquote>
</blockquote>
<p>（3）当我们要扩展某个类的某个功能时，可以使用代理模式，在代理类中进行简单扩展</p>
<h2 id="4-装饰者模式"><a href="#4-装饰者模式" class="headerlink" title="4.装饰者模式"></a>4.装饰者模式</h2><p>使用条件：</p>
<blockquote>
</blockquote>
<p>1.增强的类和被增强的类实现相同的接口</p>
<blockquote>
</blockquote>
<p>2.在增强的类中获得被增强的类的引用</p>
</section><nav id="post-nav"><span class="prev"></span><span class="next"><a href="/2018/06/16/jvm知识/">Older Posts<span class="arrow">→</span></a></span></nav></article></section><footer id="footer"><div id="social"><a class="symbol" href="https://github.com/fairyll"><i class="fa fa-github"></i></a></div><p class="small">因果也是种选择 &nbsp<i class="fa fa-heart" aria-hidden="true">&nbsp Fairy</i></p></footer></body></html>