<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1"><title>多线程相关知识点</title><link rel="shortcut icon" href="/images/avatar.png"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/css/highlight.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"></head><body><nav class="main-nav"><a href="/">首页</a><a href="/archives">归档</a></nav><div class="profile"><section id="wrapper"><header id="header"><a href="/about"><img class="2x" id="avatar" src="/images/avatar.png"></a><h1>Fairy</h1><h2></h2></header></section></div><section class="post" id="wrapper"><article><header><h1>多线程相关知识点</h1><h2 class="headline">Jun 09, 2018 1:53·3,653 words
·13 minutes read<span class="tags"></span></h2></header><div id="toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#线程创建方式"><span class="toc-text">线程创建方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-继承Thread类创建线程"><span class="toc-text">1.继承Thread类创建线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-实现Runnable接口创建线程"><span class="toc-text">2.实现Runnable接口创建线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-使用Callable接口和Future接口创建线程"><span class="toc-text">3.使用Callable接口和Future接口创建线程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程五种状态-新建-就绪-运行-阻塞-死亡"><span class="toc-text">线程五种状态(新建,就绪,运行,阻塞,死亡)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-新建状态-New"><span class="toc-text">1.新建状态(New)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-就绪状态-Runnable"><span class="toc-text">2.就绪状态(Runnable)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-运行状态-Running"><span class="toc-text">3.运行状态(Running)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-阻塞状态-Blocked"><span class="toc-text">4. 阻塞状态(Blocked)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-死亡状态-Dead"><span class="toc-text">5. 死亡状态(Dead)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程锁机制"><span class="toc-text">线程锁机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#悲观锁"><span class="toc-text">悲观锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#乐观锁"><span class="toc-text">乐观锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自旋锁与自适应自旋"><span class="toc-text">自旋锁与自适应自旋</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁清除："><span class="toc-text">锁清除：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁粗化："><span class="toc-text">锁粗化：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁升级"><span class="toc-text">锁升级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#偏向锁"><span class="toc-text">偏向锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#轻量级锁："><span class="toc-text">轻量级锁：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重量级锁："><span class="toc-text">重量级锁：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程池"><span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池的好处"><span class="toc-text">线程池的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#本地线程"><span class="toc-text">本地线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程适用的场景"><span class="toc-text">线程适用的场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#产生死锁的四个必要条件"><span class="toc-text">产生死锁的四个必要条件</span></a></li></ol></div><section id="post-body"><h1 id="线程创建方式"><a href="#线程创建方式" class="headerlink" title="线程创建方式"></a>线程创建方式</h1><h2 id="1-继承Thread类创建线程"><a href="#1-继承Thread类创建线程" class="headerlink" title="1.继承Thread类创建线程"></a>1.继承Thread类创建线程</h2><blockquote>
<p>步骤:<br>1.定义Thread类的子类,并重写该类的run()方法,该方法的方法体就是线程需要完成的任务,run()方法也称为线程执行体。</p>
</blockquote>
<p>2.创建Thread子类的实例，也就是创建了线程对象</p>
<blockquote>
</blockquote>
<p>3.启动线程，即调用线程的start()方法</p>
<blockquote>
</blockquote>
<pre><code>代码实例:
public class MyThread extends Thread{//继承Thread
     public void run(){
        //重写run方法
     }
}
public class Main {
     public static void main(String[] args){
    　new MyThread().start();//创建并启动线程
    }
}
</code></pre><h2 id="2-实现Runnable接口创建线程"><a href="#2-实现Runnable接口创建线程" class="headerlink" title="2.实现Runnable接口创建线程"></a>2.实现Runnable接口创建线程</h2><blockquote>
<p>步骤:<br>1.定义Runnable接口的实现类，重写run()方法，run()方法为线程的执行体.</p>
</blockquote>
<p>2.创建Runnable实现类的实例，并用这个实例作为Thread的target来创建Thread对象， <strong>这个Thread对象才是真正的线程对象</strong> </p>
<blockquote>
</blockquote>
<p>3.通过调用线程对象的start()方法来启动线程</p>
<blockquote>
</blockquote>
<pre><code>代码实例:
public class MyThread2 implements Runnable{//实现Runnable接口
    public void run(){
    //重写run方法
    }
}
public class Main {
    public static void main(String[] args){
        //创建并启动线程
        new Thread(new MyThread2()).start();
    }
}
</code></pre><h2 id="3-使用Callable接口和Future接口创建线程"><a href="#3-使用Callable接口和Future接口创建线程" class="headerlink" title="3.使用Callable接口和Future接口创建线程"></a>3.使用Callable接口和Future接口创建线程</h2><p>和Runnable接口不一样，Callable接口提供了一个call（）方法作为线程执行体，call()方法比run()方法功能要强大。</p>
<blockquote>
</blockquote>
<p>1.call( )方法可以有返回值</p>
<blockquote>
</blockquote>
<p>2.call( )方法可以声明抛出异常</p>
<blockquote>
</blockquote>
<pre><code>Java5提供了Future接口来代表Callable接口里call()方法的返回值，并且为Future接口提供了一个实现类FutureTask，这个实现类既实现了Future接口，还实现了Runnable接口，因此可以作为Thread类的target。
</code></pre><blockquote>
<p>步骤:<br>1.创建Callable接口的实现类，并实现call()方法，然后创建该实现类的实例（从java8开始可以直接使用Lambda表达式创建Callable对象）。</p>
</blockquote>
<p>2.使用FutureTask类来包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值</p>
<blockquote>
</blockquote>
<p>3.使用FutureTask对象作为Thread对象的target创建并启动线程（因为FutureTask实现了Runnable接口）</p>
<blockquote>
</blockquote>
<p>4.调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p>
<blockquote>
</blockquote>
<pre><code>public class Main {
    public static void main(String[] args){
        MyThread3 th=new MyThread3();
         //使用Lambda表达式创建Callable对象
         //使用FutureTask类来包装Callable对象
         FutureTask&lt;Integer&gt; future=new FutureTask&lt;Integer&gt;(
             (Callable&lt;Integer&gt;)()-&gt;{
                 return 5;
             }
         );
         new Thread(task,&quot;有返回值的线程&quot;).start();//实质上还是以Callable对象来创建并启动线程
         try{
             System.out.println(&quot;子线程的返回值：&quot;+future.get());//get()方法会阻塞，直到子线程执行结束才返回
         }catch(Exception e){
             ex.printStackTrace();
         }
     }
 }
</code></pre><h1 id="线程五种状态-新建-就绪-运行-阻塞-死亡"><a href="#线程五种状态-新建-就绪-运行-阻塞-死亡" class="headerlink" title="线程五种状态(新建,就绪,运行,阻塞,死亡)"></a>线程五种状态(新建,就绪,运行,阻塞,死亡)</h1><h2 id="1-新建状态-New"><a href="#1-新建状态-New" class="headerlink" title="1.新建状态(New)"></a>1.新建状态(New)</h2><pre><code>当用new操作创建一个线程时， 例如new Thread(r)，线程还没有开始运行，此时线程处在新建状态。 当一个线程处于新生状态时，程序还没有开始运行线程中的代码
</code></pre><h2 id="2-就绪状态-Runnable"><a href="#2-就绪状态-Runnable" class="headerlink" title="2.就绪状态(Runnable)"></a>2.就绪状态(Runnable)</h2><pre><code>一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。

处于就绪状态的线程并不一定立即运行run()方法，线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。因为在单CPU的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个线程处于就绪状态。对多个处于就绪状态的线程是由Java运行时系统的线程调度程序(thread scheduler)来调度的。
</code></pre><h2 id="3-运行状态-Running"><a href="#3-运行状态-Running" class="headerlink" title="3.运行状态(Running)"></a>3.运行状态(Running)</h2><pre><code>当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法.
</code></pre><h2 id="4-阻塞状态-Blocked"><a href="#4-阻塞状态-Blocked" class="headerlink" title="4. 阻塞状态(Blocked)"></a>4. 阻塞状态(Blocked)</h2><blockquote>
<p>线程运行过程中，可能由于各种原因进入阻塞状态:</p>
</blockquote>
<p>1.线程通过调用sleep方法进入睡眠状态；</p>
<blockquote>
</blockquote>
<p>2.线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；</p>
<blockquote>
</blockquote>
<p>3.线程试图得到一个锁，而该锁正被其他线程持有；</p>
<blockquote>
</blockquote>
<p>4.线程在等待某个触发条件；</p>
<blockquote>
<p>所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。</p>
</blockquote>
<h2 id="5-死亡状态-Dead"><a href="#5-死亡状态-Dead" class="headerlink" title="5. 死亡状态(Dead)"></a>5. 死亡状态(Dead)</h2><blockquote>
<p>有两个原因会导致线程死亡：</p>
</blockquote>
<p>1.run方法正常退出而自然死亡，</p>
<blockquote>
</blockquote>
<p>2.一个未捕获的异常终止了run方法而使线程猝死。</p>
<blockquote>
</blockquote>
<p>为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用isAlive方法。如果是可运行或被阻塞，这个方法返回true； 如果线程仍旧是new状态且不是可运行的， 或者线程死亡了，则返回false.</p>
<h1 id="线程锁机制"><a href="#线程锁机制" class="headerlink" title="线程锁机制"></a>线程锁机制</h1><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><blockquote>
<p>假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。悲观锁假定其他线程企图访问或者改变你正在访问、更改的对象的概率是很高的，因此在悲观锁的环境中，在你开始改变此对象之前就将该对象锁住，并且直到你提交了所作的更改之后才释放锁。 </p>
</blockquote>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><blockquote>
<p>假设不会发生并发冲突。轻易不加锁。 </p>
</blockquote>
<h2 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h2><pre><code>线程挂起和恢复的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力，在许多应用中，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得，可以让后请求锁的线程等待一会儿，但不放弃处理器的执行时间，让线程执行一个忙循环（自旋）。 

自旋锁默认的自旋次数值是10次，可以使用参数-XX:PreBlockSpin更改。 

自适应自旋意味着自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。 
</code></pre><h2 id="锁清除："><a href="#锁清除：" class="headerlink" title="锁清除："></a>锁清除：</h2><pre><code>虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。 
</code></pre><h2 id="锁粗化："><a href="#锁粗化：" class="headerlink" title="锁粗化："></a>锁粗化：</h2><pre><code>如果虚拟机探测到有一系列连续操作都对同一个对象反复加锁和解锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。 
</code></pre><h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><pre><code>Java SE1.6为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。 
</code></pre><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><pre><code>Hotspot的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。 

偏向锁的撤销：偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。下图中的线程1演示了偏向锁初始化的流程，线程2演示了偏向锁撤销的流程。 
</code></pre><p>关闭偏向锁：偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟-XX：BiasedLockingStartupDelay = 0。如果你确定自己应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁-XX:-UseBiasedLocking=false，那么默认会进入轻量级锁状态。 </p>
<h2 id="轻量级锁："><a href="#轻量级锁：" class="headerlink" title="轻量级锁："></a>轻量级锁：</h2><pre><code>轻量级锁加锁：线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。 

轻量级锁解锁：轻量级解锁时，会使用原子的CAS操作来将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。下图是两个线程同时争夺锁，导致锁膨胀的流程图。 



因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。 
</code></pre><h2 id="重量级锁："><a href="#重量级锁：" class="headerlink" title="重量级锁："></a>重量级锁：</h2><pre><code>重量锁在JVM中又叫对象监视器（Monitor），它至少包含一个竞争锁的队列，和一个信号阻塞队列（wait队列），前者负责做互斥，后一个用于做线程同步。 
</code></pre><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><blockquote>
<p>线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。<br>线程池线程都是后台线程。<br>每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。<br>如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。<br>如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。<br>超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。</p>
</blockquote>
<h3 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h3><blockquote>
<p>1.重用线程池中的线程,减少因对象创建,销毁所带来的性能开销;</p>
</blockquote>
<p>2.能有效的控制线程的最大并发数,提高系统资源利用率,同时避免过多的资源竞争,避免堵塞;</p>
<blockquote>
</blockquote>
<p>3.能够多线程进行简单的管理,使线程的使用简单、高效。</p>
<h3 id="本地线程"><a href="#本地线程" class="headerlink" title="本地线程"></a>本地线程</h3><p>一个程序里面不同的执行路径</p>
<blockquote>
</blockquote>
<p>学习线程首先要理清楚三个概念：</p>
<blockquote>
</blockquote>
<p>进程：进程是一个静态的概念</p>
<blockquote>
</blockquote>
<p>线程：一个进程里面有一个主线程叫main()方法，是一个程序里面的，一个进程里面不同的执行路径。</p>
<blockquote>
</blockquote>
<p>在同一个时间点上，一个CPU只能支持一个线程在执行。因为CPU运行的速度很快，因此我们看起来的感觉就像是多线程一样。</p>
<h3 id="线程适用的场景"><a href="#线程适用的场景" class="headerlink" title="线程适用的场景"></a>线程适用的场景</h3><blockquote>
</blockquote>
<p>1 线程间有数据共享，并且数据是需要修改的（不同任务间需要大量共享数据或频繁通信时）； </p>
<blockquote>
</blockquote>
<p>2 提供非均质的服务（有优先级任务处理）事件响应有优先级； </p>
<blockquote>
</blockquote>
<p>3 单任务并行计算，在非CPU Bound的场景下提高响应速度，降低时延； </p>
<blockquote>
</blockquote>
<p>4 与人有IO交互的应用，良好的用户体验（键盘鼠标的输入，立刻响应）</p>
<h1 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h1><blockquote>
</blockquote>
<p>①互斥条件：进程对其所要求的资源进行独占性控制；</p>
<blockquote>
</blockquote>
<p>②请求保持条件：进程已经保持了至少一个资源，但又提出新的资源申请，而该资源又得不到满足，于是该进程阻塞，但其原先获得的资源保持不放；</p>
<blockquote>
</blockquote>
<p>③不可剥夺条件：进程已获得的资源在未使用完之前，不能被剥夺，只能在使用完后由自己释放；</p>
<blockquote>
</blockquote>
<p>④环路条件：当发生死锁时，在进程资源有向图中存在环路。</p>
<p>解决其中一个即可解决死锁问题.</p>
</section><nav id="post-nav"><span class="prev"><a href="/2018/06/10/hello-world/"><span class="arrow">←</span>Newer Posts</a></span><span class="next"><a href="/2018/06/09/集合接口中用的较多的底层实现/">Older Posts<span class="arrow">→</span></a></span></nav></article></section><footer id="footer"><div id="social"><a class="symbol" href="https://github.com/fairyll"><i class="fa fa-github"></i></a></div><p class="small">因果也是种选择 &nbsp<i class="fa fa-heart" aria-hidden="true">&nbsp Fairy</i></p></footer></body></html>