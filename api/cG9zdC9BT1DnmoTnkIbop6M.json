{"title":"AOP的理解","date":"2018-07-18T16:00:00.000Z","excerpt":"","slug":"AOP的理解","updated":"2018-08-09T08:54:58.995Z","content":"<p>详细介绍AOP概念理解以及作用</p>\n<h3 id=\"AOP：面向切面编程\"><a href=\"#AOP：面向切面编程\" class=\"headerlink\" title=\"AOP：面向切面编程\"></a>AOP：面向切面编程</h3><p>在软件业，AOP为Aspect Oriented Programming的缩写，意为：<strong>面向切面编程</strong>，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</p>\n<p>AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。</p>\n<p>利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>\n<p>AOP是一个概念，并没有设定具体语言的实现，它能克服那些只有单继承特性语言的缺点，Spring2.0之后整合AspectJ第三方AOP技术。</p>\n<p>AspectJ是一个面向切面的框架，它扩展了Java语言。AspectJ定义了AOP语法所以它有一个专门的编译器用来生成遵守Java字节编码规范的Class文件。</p>\n<h3 id=\"AOP自我理解\"><a href=\"#AOP自我理解\" class=\"headerlink\" title=\"AOP自我理解\"></a>AOP自我理解</h3><p>以上来自百度百科，理解起来还是比较笼统的，下面来谈谈自己的理解</p>\n<h4 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h4><p>首先说说框架：因为到目前软件系统发展到今天已经很复杂了，特别是服务器端软件，涉及到的知识，内容，问题太多。在某些方面使用别人成熟的框架，就相当于让别人帮你完成一些基础工作，你只需要集中精力完成系统的业务逻辑设计。而且框架一般是成熟，稳健的，他可以处理系统很多细节问题，比如，事务处理，安全性，数据流控制等问题。还有框架一般都经过很多人使用，所以结构很好，扩展性也很好，而且它是不断升级的，你可以直接享受别人升级代码带来的好处。  </p>\n<h4 id=\"两个目的\"><a href=\"#两个目的\" class=\"headerlink\" title=\"两个目的\"></a>两个目的</h4><p><strong>所以就有一个很浅显的道理，在编程中所用到的框架、思想或者技术等基本上都是基于两个目的：</strong></p>\n<ol>\n<li>提高项目开发效率（编程、测试、上线），它可以让开发人员使用更少的代码量完成同样的功能实现，并且在安全、稳健、结构、事务等性能方面有卓越表现。</li>\n<li>便于项目上线后的维护，使用框架或者某个技术后，程序就能具有更好的结构，以便于后期的升级与维护，同样能让开发人员使用更少的代码量完成同样的功能实现。</li>\n</ol>\n<p><strong>理解了这个问题后，就可以了解AOP的功能以及在哪能够节省代码</strong></p>\n<h4 id=\"理解AOP\"><a href=\"#理解AOP\" class=\"headerlink\" title=\"理解AOP\"></a>理解AOP</h4><p><strong>AOP即面向切面编程，能在不影响原有功能的前提下，为程序提供横向扩展的功能</strong></p>\n<h4 id=\"横向扩展\"><a href=\"#横向扩展\" class=\"headerlink\" title=\"横向扩展\"></a>横向扩展</h4><p>横向扩展：理解了这个词基本就能理解AOP</p>\n<p>软件开发可分为”持久层”，”业务层”，”控制器层”</p>\n<p>所谓的”横向”就是指上面说到的三个层里的任意一层</p>\n<p>使用AOP技术后，用一个方法，就能同时作用与一个层面内所有方法</p>\n<h4 id=\"在哪节省代码？\"><a href=\"#在哪节省代码？\" class=\"headerlink\" title=\"在哪节省代码？\"></a>在哪节省代码？</h4><p>举个栗子</p>\n<p>写日志是一个很好的编程习惯，不用AOP技术的话实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(&quot;方法开始执行&quot;);</span><br><span class=\"line\">public void a()&#123;</span><br><span class=\"line\">    System.out.println(&quot;执行方法&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println(&quot;方法执行成功&quot;);</span><br></pre></td></tr></table></figure>\n<p>上述是一个很简单的日志，虽然只有两行代码也不多</p>\n<p>可是在开发中，面对100个甚至1000个方法时，这样写的话会不会被累死？</p>\n<p>但如果用AOP的话，用一个方法就可以搞定所有的日志</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//指定要监控的bean中的方法</span><br><span class=\"line\">@Around(&quot;bean(*Service)&quot;)</span><br><span class=\"line\">//参数的意思是代理执行原软件中的方法</span><br><span class=\"line\">public Object testObject(ProceedingJoinPoint jp) throws Throwable&#123; </span><br><span class=\"line\">\t//在方法执行之前执行</span><br><span class=\"line\">\tSystem.out.println(jp.getSignature()+&quot;开始执行&quot;);</span><br><span class=\"line\">\tObject val = jp.proceed();\t</span><br><span class=\"line\">\t//在方法执行之后执行</span><br><span class=\"line\">\tSystem.out.println(jp.getSignature()+&quot;执行成功&quot;);</span><br><span class=\"line\">\treturn val;\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在所有业务层的方法执行前后都会打出对应日志了</p>\n<p>一个方法搞定了需要机械重复的复制粘贴几百行的工作，节省的代码有一碗饭这么多啊有木有</p>\n<h3 id=\"AOP作用和优势\"><a href=\"#AOP作用和优势\" class=\"headerlink\" title=\"AOP作用和优势\"></a>AOP作用和优势</h3><p>显然刚刚的栗子足以说明AOP的优势，当然开发中不止记录日志那么简单</p>\n<h4 id=\"AOP主要功能\"><a href=\"#AOP主要功能\" class=\"headerlink\" title=\"AOP主要功能\"></a>AOP主要功能</h4><p>日志记录，性能统计，安全控制，事务处理，异常处理等</p>\n<h4 id=\"AOP主要目的\"><a href=\"#AOP主要目的\" class=\"headerlink\" title=\"AOP主要目的\"></a>AOP主要目的</h4><p>将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码。</p>\n<h4 id=\"AOP优势\"><a href=\"#AOP优势\" class=\"headerlink\" title=\"AOP优势\"></a>AOP优势</h4><p>AOP技术的优势是显而易见的。在面向对象的世界里，人们提出了各种方法和设计原则来保障系统的可复用性与可扩展性，以期建立一个松散耦合、便于扩展的软件系统。例如GOF提出的“设计模式”，为我们提供了设计的典范与准则。设计模式通过最大程度的利用面向对象的特性，诸如利用继承、多态，对责任进行分离、对依赖进行倒置，面向抽象，面向接口，最终设计出灵活、可扩展、可重用的类库、组件，乃至于整个系统的架构。在设计的过程中，通过各种模式体现对 象的行为、暴露的接口、对象间关系、以及对象分别在不同层次中表现出来的形态。然而鉴于对象封装的特殊性，“设计模式”的触角始终在接口与抽象中大做文 章，而对于对象内部则无能为力。</p>\n<p>通过”横切”技术，AOP技术就能深入到对象内部翻云覆雨，截取方法之间传递的消息为我所用。由于将核心关注点与横切关注点完全隔离，使得我们能够独立的对”方面”编程。它允许开发者动态地修改静态的OO模型，构造出一个能够不断增长以满足新增需求的系统，就象现实世界中的对象会在其生命周期中不断改变自身，应用程序也可以在发展中拥有新的功能。</p>\n<p><strong>那么设计软件系统时应用AOP技术，其优势在于：</strong></p>\n<ol>\n<li>在定义应用程序对某种服务（例如日志）的所有需求的时候。通过识别关注点，使得该服务能够被更好的定义，更好的被编写代码，并获得更多的功能。这种方式还能够处理在代码涉及到多个功能的时候所出现的问题，例如改变某一个功能可能会影响到其它的功能，在AOP中把这样的麻烦称之为”纠结（tangling）”。</li>\n<li>利用AOP技术对离散的方面进行的分析将有助于为开发团队指定一位精于该项工作的专家。负责这项工作的最佳人选将可以有效利用自己的相关技能和经验。</li>\n<li>持久性。标准的面向对象的项目开发中，不同的开发人员通常会为某项服务编写相同的代码，例如日志记录。随后他们会在自己的实施中分别对日志进行处理以满足不同单个对象的需求。而通过创建一段单独的代码片段，AOP提供了解决这一问题的持久简单的方案，这一方案强调了未来功能的重用性和易维护性：不需要在整个应用程序中一遍遍重新编写日志代码，AOP使得仅仅编写日志方面（logging aspect）成为可能，并且可以在这之上为整个应用程序提供新的功能。</li>\n</ol>\n<p><strong>总而言之，AOP技术的优势使得需要编写的代码量大大缩减，节省了时间，控制了开发成本。同时也使得开发人员可以集中关注于系统的核心商业逻辑。此外，它更利于创建松散耦合、可复用与可扩展的大型软件系统。</strong></p>\n<h3 id=\"AOP与OOP区别与联系\"><a href=\"#AOP与OOP区别与联系\" class=\"headerlink\" title=\"AOP与OOP区别与联系\"></a>AOP与OOP区别与联系</h3><p>OOP（面向对象编程）针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的逻辑单元划分。</p>\n<p>AOP则是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。这两种设计思想在目标上有着本质的差异。</p>\n<p><strong>换而言之，OOD/OOP面向名词领域，AOP面向动词领域。</strong></p>\n<p>AOP可以说是OOP的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需 要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，<strong>OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系</strong>。例如日志功能。日 志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种 散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p>\n<p>而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为 “Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低 模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。</p>\n<h3 id=\"AOP实现\"><a href=\"#AOP实现\" class=\"headerlink\" title=\"AOP实现\"></a>AOP实现</h3><p>AOP分为静态AOP和动态AOP。静态AOP是指AspectJ实现的AOP，他是将切面代码直接编译到Java类文件中。动态AOP是指将切面代码进行动态织入实现的AOP。Spring的AOP为动态AOP，实现的技术为： JDK提供的动态代理技术 和 CGLIB(动态字节码增强技术) </p>\n<p><strong>所以实现AOP的技术，主要分为两大类：</strong></p>\n<ol>\n<li>采用<strong>动态代理技术</strong>，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行</li>\n<li>采用<strong>静态织入</strong>，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。</li>\n</ol>\n<p><strong>然而殊途同归，实现AOP的技术特性却是相同的，分别为：</strong></p>\n<ol>\n<li>目标对象target：指的是需要被增强的对象，由于spring aop是通过代理模式实现，从而这个对象永远是被代理对象。</li>\n<li><p>连接点join point：所谓连接点是指那些被拦截到的点，在spring中这些点指的是方法，因为spring只支持方法类型的连接点</p>\n</li>\n<li><p>切入点pointcut：表示一组 join point，这些 join point 或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的 Advice 将要发生的地方，简单说切入点是指我们要对哪些连接点进行拦截的定义</p>\n</li>\n<li><p>通知advice：所谓通知是指拦截到连接点之后所要做的事情就是通知，通知分为前置通知，后置通知，异常通知，最终通知，环绕通知。Advice 定义了在 pointcut 里面定义的程序点具体要做的操作</p>\n</li>\n<li><p>引介introduction：引介是一种特殊的通知，在不修改类代码的前提下，introduction可以在运行期为类动态地添加一些方法或属性</p>\n</li>\n<li><p>切面aspect：是切入点和通知的结合</p>\n</li>\n<li><p>织入weaving：织入是一个过程，是将切面应用到目标对象从而创建出AOP代理对象的过程，织入可以在编译期，类装载期，运行期进行。Spring采用动态织入，而aspectj采用静态织入</p>\n</li>\n<li><p>代理Proxy：一个类被AOP织入增强后，就产生一个结果代理类</p>\n</li>\n</ol>\n<p><strong>简单点说：</strong></p>\n<ul>\n<li><p>目标对象target：被代理增强的对象</p>\n</li>\n<li><p>连接点join point：被拦截到的方法</p>\n</li>\n<li><p>切入点(pointcut)：被拦截到的方法当中可以插入的增强的方法</p>\n</li>\n<li><p>通知(advice)：增强的代码</p>\n</li>\n<li><p>引介introduction：作用在类上，可以为一个类增加属性和方法</p>\n</li>\n<li><p>切面aspect：通知和切点的结合，指定把什么（增强）插入到哪里（切点）去</p>\n</li>\n<li><p>织入weaving：通知插入到切点的过程</p>\n</li>\n<li><p>代理Proxy：通知插入到切点是通过代理完成的</p>\n</li>\n</ul>\n<p><strong>上述的技术特性组成了基本的AOP技术，大多数AOP工具均实现了这些技术。它们也可以是研究AOP技术的基本术语。</strong></p>\n<hr>\n<p>至于Spring是如何整合AOP的，以后再详细写写</p>\n<p><br><br>参考资料：</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://baike.baidu.com/item/AOP/1332219\" target=\"_blank\" rel=\"noopener\">百度百科 - AOP </a></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://www.cnblogs.com/jingzhishen/p/4980551.html\" target=\"_blank\" rel=\"noopener\">AOP面向切面编程</a></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://blog.csdn.net/mggwct/article/details/54893371\" target=\"_blank\" rel=\"noopener\">Spring AOP两种方式实现</a></p>\n<p><br><br></p>\n","next":{"title":"随笔二","slug":"随笔二"},"link":"/2018/07/19"}