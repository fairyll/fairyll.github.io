{"title":"集合接口中用的较多的底层实现","date":"2018-06-09T04:50:45.291Z","excerpt":"","slug":"集合接口中用的较多的底层实现","updated":"2018-06-10T02:53:21.506Z","content":"<h2 id=\"单列集合-Collection接口\"><a href=\"#单列集合-Collection接口\" class=\"headerlink\" title=\"单列集合(Collection接口)\"></a>单列集合(Collection接口)</h2><p>单列集合又分为list集合与set集合</p>\n<h3 id=\"A-List接口-有序-有索引-允许重复\"><a href=\"#A-List接口-有序-有索引-允许重复\" class=\"headerlink\" title=\"A. List接口(有序,有索引,允许重复)\"></a>A. List接口(有序,有索引,允许重复)</h3><h4 id=\"1-ArrayList\"><a href=\"#1-ArrayList\" class=\"headerlink\" title=\"1.ArrayList\"></a>1.ArrayList</h4><blockquote>\n<p>底层是数组结构,具有查询快,增删慢的特点<br>线程不同步:所以不安全,但效率高</p>\n</blockquote>\n<h4 id=\"2-LinkedList\"><a href=\"#2-LinkedList\" class=\"headerlink\" title=\"2.LinkedList\"></a>2.LinkedList</h4><blockquote>\n<p>底层是链表结构,具有查询慢,增删快的特点<br>线程不同步</p>\n</blockquote>\n<h4 id=\"3-Vector\"><a href=\"#3-Vector\" class=\"headerlink\" title=\"3.Vector\"></a>3.Vector</h4><blockquote>\n<p>底层是数组结构,具有查询快,增删慢的特点<br>线程同步:所以安全,但效率低</p>\n</blockquote>\n<h3 id=\"B-Set接口-无序-无索引-不允许重复\"><a href=\"#B-Set接口-无序-无索引-不允许重复\" class=\"headerlink\" title=\"B.Set接口(无序,无索引,不允许重复)\"></a>B.Set接口(无序,无索引,不允许重复)</h3><h4 id=\"1-HashSet-线程不同步\"><a href=\"#1-HashSet-线程不同步\" class=\"headerlink\" title=\"1.HashSet(线程不同步)\"></a>1.HashSet(线程不同步)</h4><blockquote>\n<p>集合中存储数据的位置是根据元素的哈希值来判断的,<br>哈希值是根据元素的地址值来计算的,<br>当元素的哈希值一样时,则使用equals方法来比较两个元素<br>     <strong>(注意:如果元素类没有重写equals方法,则使用父类的equals方法)</strong> </p>\n<pre><code>HashSet保证元素唯一性的方法:\n复写hashCode和equals方法,当两个方法都重复时才认为元素重复\n</code></pre></blockquote>\n<h4 id=\"2-LinkedHashSet-线程不同步\"><a href=\"#2-LinkedHashSet-线程不同步\" class=\"headerlink\" title=\"2.LinkedHashSet(线程不同步)\"></a>2.LinkedHashSet(线程不同步)</h4><blockquote>\n<p>既能保证元素有序,又能保证元素唯一</p>\n</blockquote>\n<pre><code>继承了HashSet,所以保证元素唯一性的方法与HashSet相同:\n复写hashCode和equals方法,当两个方法都重复时才认为元素重复\n</code></pre><h4 id=\"3-TreeSet-线程不同步\"><a href=\"#3-TreeSet-线程不同步\" class=\"headerlink\" title=\"3.TreeSet(线程不同步)\"></a>3.TreeSet(线程不同步)</h4><blockquote>\n<p>可以将元素自动排序<br>排序的规则有我们自己指定:</p>\n<pre><code>* 元素类实现comparable&lt;E&gt;接口,复写compareTo()方法\n</code></pre><p>也可以保证元素唯一性:</p>\n<pre><code>* 根据我们自己指定的排序判断来判断元素是否相同\n</code></pre></blockquote>\n<h2 id=\"双列集合-Map接口\"><a href=\"#双列集合-Map接口\" class=\"headerlink\" title=\"双列集合(Map接口)\"></a>双列集合(Map接口)</h2><h4 id=\"1-HashMap-线程不同步\"><a href=\"#1-HashMap-线程不同步\" class=\"headerlink\" title=\"1.HashMap(线程不同步)\"></a>1.HashMap(线程不同步)</h4><blockquote>\n<p>保证键的唯一性:<br>键的类要复写hashCode和equals方法</p>\n</blockquote>\n<h4 id=\"2-LinkedHashMap-线程不同步\"><a href=\"#2-LinkedHashMap-线程不同步\" class=\"headerlink\" title=\"2.LinkedHashMap(线程不同步)\"></a>2.LinkedHashMap(线程不同步)</h4><blockquote>\n<p>既能保证键的有序,也能保证键的唯一性:<br>键的类要复写hashCode和equals方法</p>\n</blockquote>\n<h4 id=\"3-TreeMap-线程不同步\"><a href=\"#3-TreeMap-线程不同步\" class=\"headerlink\" title=\"3.TreeMap(线程不同步)\"></a>3.TreeMap(线程不同步)</h4><blockquote>\n<p>可以将键自动排序<br>排序的规则由我们自己指定:</p>\n<ul>\n<li>键实现comparable<e>接口,复写compareTo方法<br>也可以保证键唯一性: </e></li>\n<li>不过是根据我们自己指定排序判断来判断键是否相同</li>\n</ul>\n</blockquote>\n","prev":{"title":"多线程相关知识点","slug":"多线程"},"next":{"title":"POJO和JavaBean的区别","slug":"pojo与javaBean"},"link":"/2018/06/09","toc":[{"title":"单列集合(Collection接口)","id":"单列集合-Collection接口","index":"1","children":[{"title":"A. List接口(有序,有索引,允许重复)","id":"A-List接口-有序-有索引-允许重复","index":"1.1","children":[{"title":"1.ArrayList","id":"1-ArrayList","index":"1.1.1"},{"title":"2.LinkedList","id":"2-LinkedList","index":"1.1.2"},{"title":"3.Vector","id":"3-Vector","index":"1.1.3"}]},{"title":"B.Set接口(无序,无索引,不允许重复)","id":"B-Set接口-无序-无索引-不允许重复","index":"1.2","children":[{"title":"1.HashSet(线程不同步)","id":"1-HashSet-线程不同步","index":"1.2.1"},{"title":"2.LinkedHashSet(线程不同步)","id":"2-LinkedHashSet-线程不同步","index":"1.2.2"},{"title":"3.TreeSet(线程不同步)","id":"3-TreeSet-线程不同步","index":"1.2.3"}]}]},{"title":"双列集合(Map接口)","id":"双列集合-Map接口","index":"2"}]}