{"title":"jvm知识点小结之一","date":"2018-06-16T13:31:32.070Z","excerpt":"","slug":"jvm知识","updated":"2018-06-16T13:38:34.757Z","content":"<h2 id=\"类的实例化顺序\"><a href=\"#类的实例化顺序\" class=\"headerlink\" title=\"类的实例化顺序\"></a>类的实例化顺序</h2><p>1.父类的静态变量和静态代码块<br>2.执行子类的静态变量和静态代码块<br>3.执行父类的成员变量赋值<br>4.执行父类的构造代码块<br>5.执行父类的构造方法（）<br>6.执行子类的构造代码块<br>7.执行子类的构造方法（）；</p>\n<h2 id=\"JVM的内存可分为3个区：\"><a href=\"#JVM的内存可分为3个区：\" class=\"headerlink\" title=\"JVM的内存可分为3个区：\"></a>JVM的内存可分为3个区：</h2><h2 id=\"堆-heap-、栈-stack-和方法区-method\"><a href=\"#堆-heap-、栈-stack-和方法区-method\" class=\"headerlink\" title=\"堆(heap)、栈(stack)和方法区(method)\"></a>堆(heap)、栈(stack)和方法区(method)</h2><h3 id=\"堆区\"><a href=\"#堆区\" class=\"headerlink\" title=\"堆区:\"></a>堆区:</h3><p>1.存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令)<br>2.jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身</p>\n<h3 id=\"栈区\"><a href=\"#栈区\" class=\"headerlink\" title=\"栈区:\"></a>栈区:</h3><p>1.每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)，对象都存放在堆区中<br>2.每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。<br>3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。</p>\n<h3 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区:\"></a>方法区:</h3><p>1.又叫静态区，跟堆一样，被所有的线程共享。<br>2.方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。</p>\n<h2 id=\"垃圾回收机制-GC\"><a href=\"#垃圾回收机制-GC\" class=\"headerlink\" title=\"垃圾回收机制(GC)\"></a>垃圾回收机制(GC)</h2><p>垃圾收集机制是指jvm用于释放那些不再使用的对象所占用的内存。</p>\n<p>工作原理:</p>\n<blockquote>\n<p>引用计数:标记复制”引用计数”是一种简单但速度很慢的垃圾回收技术.所有对象都有一个引用计数器,当有引用连接时计数器加1,当引用离开作用域时或者被置于NULL时,计数器-1,垃圾回收器会在所有包含对象引用的列表上进行遍历,当发现某个对象的引用计数为0时,就释放占用的空间.”标记复制”的运行机制,垃圾回收器遍历包含所有引用的列表,当发现存活的对象引用时做上标记,这样当遍历完所有对象引用并做上标记的时候,执行垃圾回收,将没有标记的对象堆空间释放.</p>\n</blockquote>\n<h3 id=\"内存优化\"><a href=\"#内存优化\" class=\"headerlink\" title=\"内存优化\"></a>内存优化</h3><p>1.内存溢出的错误,一般是由于代码产生的,此时应该优化程序:</p>\n<blockquote>\n</blockquote>\n<p>第一，避免死循环。仔细检查程序，防止出现死循环，这是比较容易检查的。</p>\n<blockquote>\n</blockquote>\n<p>第二，可以适当手动回收垃圾，即使调用System.gc()或Runtime.gc()。</p>\n<blockquote>\n</blockquote>\n<p>第三，应该及时释放各种资源：内存, 数据库的各种连接。释放资源的时候不能依赖于java的垃圾自动回收机制，最好也不要用finalize方法，因为无用单元回收不是一个完全可以确定的过程，作为低优先级进程，往往是系统没有内存时才调用垃圾回收进程。</p>\n<p>2.增加jvm的内存大小</p>\n<blockquote>\n</blockquote>\n<p>一般来讲，设置JVM的堆栈内存会涉及到下面四个参数：</p>\n<blockquote>\n</blockquote>\n<ul>\n<li>Xmx     设置Java Heap最大值，如-Xmx128m ，默认值为物理内存的1/4，最佳设值应该视物理内存大小及计算机内其他内存开销而定；</li>\n<li>Xms     设置Java Heap初始值，如-Xms64m ， Server端JVM最好将-Xms和-Xmx设为相同值，开发测试机JVM可以保留默认值；</li>\n<li>Xmn     设置Java Heap Young区大小，如-Xmn32m ， 不熟悉最好保留默认值；</li>\n<li>Xss      设置每个线程的Stack大小，如-Xss16m ， 不熟悉最好保留默认值；<blockquote>\n</blockquote>\n还有两个参数是跟非堆栈内存有关的：<blockquote>\n</blockquote>\n</li>\n<li>XX:PermSize             设置非堆内存初始大小，如-XX:PermSize=56m，默认是物理内存的1/6 ；</li>\n<li>XX:MaxPermSize       设置最大非堆内存的大小，如-XX:MaxPermSize=128m，默认是物理内存的1/4 ；</li>\n</ul>\n","prev":{"title":"常见的设计模式","slug":"设计模式"},"next":{"title":"Oracle数据库常用指令","slug":"Oracle常用指令"},"link":"/2018/06/16","toc":[{"title":"类的实例化顺序","id":"类的实例化顺序","index":"1"},{"title":"堆(heap)、栈(stack)和方法区(method)","id":"堆-heap-、栈-stack-和方法区-method","index":"2","children":[{"title":"堆区:","id":"堆区","index":"2.1"},{"title":"栈区:","id":"栈区","index":"2.2"},{"title":"方法区:","id":"方法区","index":"2.3"}]},{"title":"垃圾回收机制(GC)","id":"垃圾回收机制-GC","index":"3","children":[{"title":"内存优化","id":"内存优化","index":"3.1"}]}]}